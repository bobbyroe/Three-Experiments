// Generated by CoffeeScript 1.6.2
(function() {
  var camera, col, color, controls, createVortex, damping, diff, getMover, getWireMat, grid_size, i, is_paused, log, max_velocity, mouse, num_particles, onKeyed, onMouseMoved, particle_geo, particle_mat, particles, particles_update, renderFrame, renderer, scene, spacing, t, use_vortex, vel, vertex, vortex, windowHalf;

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
  camera.position.z = 200;
  renderer = new THREE.WebGLRenderer();
  controls = new THREE.TrackballControls(camera);
  log = console.log.bind(console);
  controls.rotateSpeed = 1.0;
  controls.zoomSpeed = 1.2;
  controls.panSpeed = 0.8;
  controls.noZoom = false;
  controls.noPan = false;
  controls.staticMoving = true;
  controls.dynamicDampingFactor = 0.3;
  controls.keys = [65, 83, 68];
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  use_vortex = false;
  is_paused = false;
  mouse = {
    x: 0,
    y: 0
  };
  windowHalf = {
    x: window.innerWidth * 0.5,
    y: window.innerHeight * 0.5
  };
  t = 0;
  particle_geo = new THREE.Geometry();
  grid_size = 40;
  num_particles = grid_size * grid_size;
  spacing = 1;
  i = 0;
  while (i < num_particles) {
    color = new THREE.Color();
    col = i === 0 ? 0.15 : 0.0;
    color.setHSL(col, 1.0, 0.5);
    vertex = {
      x: i % grid_size * spacing - (grid_size * 0.5 * spacing),
      y: (Math.floor(i / grid_size)) * spacing - (grid_size * 0.5 * spacing),
      z: 0
    };
    vertex.velocity = {
      x: 0,
      y: 0,
      z: 0
    };
    vertex.age = 0;
    vertex.lifespan = 3;
    particle_geo.vertices.push(vertex);
    particle_geo.colors.push(color);
    i += 1;
  }
  particle_mat = new THREE.ParticleSystemMaterial({
    size: 1,
    vertexColors: true
  });
  particles = new THREE.ParticleSystem(particle_geo, particle_mat);
  scene.add(particles);
  getMover = function() {
    return {
      goal: {
        speed: {
          x: 1,
          y: 1,
          z: 1
        },
        move_scale: {
          x: 1,
          y: 1,
          z: 1
        },
        offset: {
          x: 1,
          y: 1,
          z: 1
        }
      },
      speed: {
        x: 1,
        y: 1,
        z: 1,
        prob: {
          x: 1,
          y: 1,
          z: 1
        }
      },
      move_scale: {
        x: 1,
        y: 1,
        z: 1,
        prob: {
          x: 1,
          y: 1,
          z: 1
        }
      },
      offset: {
        x: 1,
        y: 1,
        z: 1,
        prob: {
          x: 1,
          y: 1,
          z: 1
        }
      },
      rate: 0.002,
      getPos: function(pos) {
        var position;

        this.speed.prob.x = Math.random();
        if (this.speed.prob.x < 0.05) {
          this.goal.speed.x = Math.random() * 1 + 0.2;
        }
        this.move_scale.prob.x = Math.random();
        if (this.move_scale.prob.x < 0.05) {
          this.goal.move_scale.x = Math.random() * 50 + 2;
        }
        this.move_scale.x -= (this.move_scale.x - this.goal.move_scale.x) * 0.01;
        this.offset.prob.x = Math.random();
        if (this.offset.prob.x < 0.05) {
          this.goal.offset.x = Math.random() * 200 - 100;
        }
        this.offset.x -= (this.offset.x - this.goal.offset.x) * this.rate;
        this.speed.prob.y = Math.random();
        if (this.speed.prob.y < 0.05) {
          this.goal.speed.y = Math.random() * 1 + 0.2;
        }
        this.move_scale.prob.y = Math.random();
        if (this.move_scale.prob.y < 0.05) {
          this.goal.move_scale.y = Math.random() * 50 + 2;
        }
        this.move_scale.y -= (this.move_scale.y - this.goal.move_scale.y) * 0.01;
        this.offset.prob.y = Math.random();
        if (this.offset.prob.y < 0.05) {
          this.goal.offset.y = Math.random() * 200 - 100;
        }
        this.offset.y -= (this.offset.y - this.goal.offset.y) * this.rate;
        this.speed.prob.z = Math.random();
        if (this.speed.prob.z < 0.05) {
          this.goal.speed.z = Math.random() * 1 + 0.2;
        }
        this.move_scale.prob.z = Math.random();
        if (this.move_scale.prob.z < 0.05) {
          this.goal.move_scale.z = Math.random() * 50 + 2;
        }
        this.move_scale.z -= (this.move_scale.z - this.goal.move_scale.z) * this.rate;
        this.offset.prob.z = Math.random();
        if (this.offset.prob.z < 0.05) {
          this.goal.offset.z = Math.random() * 200 - 100;
        }
        this.offset.z -= (this.offset.z - this.goal.offset.z) * this.rate;
        return position = {
          x: Math.sin(t * this.speed.x) * this.move_scale.x,
          y: Math.cos(t * this.speed.y) * this.move_scale.y,
          z: 0
        };
      }
    };
  };
  getWireMat = function(col) {
    if (col == null) {
      col = 0x004488;
    }
    return new THREE.MeshBasicMaterial({
      color: col,
      opacity: 1,
      wireframe: false,
      wireframeLinewidth: 1
    });
  };
  createVortex = function() {
    var new_vortex, sphere, sphere_geo, toggleViz, update;

    sphere_geo = new THREE.IcosahedronGeometry(3, 2);
    sphere = new THREE.Mesh(sphere_geo, getWireMat());
    scene.add(sphere);
    update = function() {
      var pos;

      pos = this.sphere.position = this.mover.getPos();
      this.x = sphere.position.x;
      this.y = sphere.position.y;
      return this.z = 0;
    };
    toggleViz = function() {
      this.visible = !this.visible;
      return this.sphere.visible = this.visible;
    };
    return new_vortex = {
      x: sphere.position.x,
      y: sphere.position.y,
      z: sphere.position.z,
      mover: getMover(),
      speed: {
        x: 1,
        y: 1,
        z: 1
      },
      scale: 0.02,
      sphere: sphere,
      update: update,
      toggleVisibility: toggleViz,
      visible: true
    };
  };
  vortex = createVortex();
  damping = 1 - 0.005;
  max_velocity = 1;
  diff = new THREE.Vector3();
  vel = new THREE.Vector3();
  particles_update = function() {
    var factor, p, p_count;

    if (is_paused === true) {
      return;
    }
    p_count = 0;
    p = null;
    while (p_count < num_particles) {
      p = particle_geo.vertices[p_count];
      if (use_vortex === true) {
        diff.subVectors(p, vortex);
        vel.crossVectors(diff, vortex.speed);
        factor = Math.min(1 / (0.0000001 + (diff.x * diff.x + diff.y * diff.y + diff.z * diff.z) / vortex.scale), max_velocity);
        p.velocity.x += (vel.x - p.velocity.x) * factor;
        p.velocity.y += (vel.y - p.velocity.y) * factor;
        p.velocity.z += (vel.z - p.velocity.z) * factor;
      }
      p.velocity.x *= damping;
      p.velocity.y *= damping;
      p.velocity.z *= damping;
      p.x += p.velocity.x;
      p.y += p.velocity.y;
      p.z += p.velocity.x;
      p_count += 1;
    }
    particle_geo.verticesNeedUpdate = true;
  };
  renderFrame = function() {
    t += 0.02;
    requestAnimationFrame(renderFrame);
    particles_update();
    controls.update();
    vortex.update();
    return renderer.render(scene, camera);
  };
  renderFrame();
  onKeyed = function(evt) {
    var ESC, SPACE;

    log(evt.keyCode);
    SPACE = 32;
    ESC = 27;
    if (evt.keyCode === SPACE) {
      use_vortex = !use_vortex;
      if (evt.shiftKey === true) {
        vortex.toggleVisibility();
      }
    }
    if (evt.keyCode === ESC) {
      return is_paused = !is_paused;
    }
  };
  document.addEventListener('keyup', onKeyed);
  return onMouseMoved = function(evt) {
    var normalized_mouseX, normalized_mouseY;

    normalized_mouseX = (evt.clientX / window.innerWidth) * 2 - 1;
    normalized_mouseY = -(evt.clientY / window.innerHeight) * 2 + 1;
    mouse = {
      x: normalized_mouseX * windowHalf.x * 0.2,
      y: normalized_mouseY * windowHalf.y * 0.2
    };
  };
})();

/*
//@ sourceMappingURL=main.map
*/
