// Generated by CoffeeScript 1.6.2
/*
    A THREE.js experiment 2014 by http://bobbyroe.com
*/
(function() {
  var HALF_PI, camera, ctrls, d, e, emitter, emitters, getEmitter, getLineColors, getLineMat, getLineVerts, getVertices, getWireMat, gui, head_geo, log, mouse, mouse_mesh, num_emitters, num_verts, onKeyUp, onMouseMove, radius, rand_angle, renderFrame, renderer, scene, tetra_geo, toggleFollow, toggleFreeze, w, windowHalf;

  d = document;
  w = window;
  windowHalf = {
    x: w.innerWidth * 0.5,
    y: w.innerHeight * 0.5
  };
  mouse = {
    x: 0,
    y: 0
  };
  HALF_PI = Math.PI * 0.5;
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(60, w.innerWidth / w.innerHeight, 0.1, 10000);
  camera.position.z = 200;
  renderer = new THREE.WebGLRenderer({
    preserveDrawingBuffer: true
  });
  log = console.log.bind(console);
  ctrls = {
    auto_clear: true
  };
  w.ctrls = ctrls;
  gui = new dat.GUI();
  gui.add(ctrls, 'auto_clear');
  renderer.setSize(w.innerWidth, w.innerHeight);
  d.body.appendChild(renderer.domElement);
  getWireMat = function(col) {
    if (col == null) {
      col = 0xFFFF00;
    }
    return new THREE.MeshBasicMaterial({
      color: col,
      opacity: 0,
      wireframe: true,
      wireframeLinewidth: 0,
      transparent: true
    });
  };
  tetra_geo = new THREE.SphereGeometry(0.1, 3, 2);
  mouse_mesh = new THREE.Mesh(tetra_geo, getWireMat());
  scene.add(mouse_mesh);
  getLineMat = function(col) {
    if (col == null) {
      col = 0xFF0000;
    }
    return new THREE.LineBasicMaterial({
      color: col,
      linewidth: 2
    });
  };
  getVertices = function() {
    var verts;

    verts = [];
    verts.push(new THREE.Vector3(0, 0.75, 0));
    verts.push(new THREE.Vector3(0.5, -0.75, 0));
    verts.push(new THREE.Vector3(0, -0.5, 0));
    verts.push(new THREE.Vector3(-0.5, -0.75, 0));
    verts.push(new THREE.Vector3(0, 0.75, 0));
    return verts;
  };
  head_geo = new THREE.Geometry();
  head_geo.vertices = getVertices();
  num_verts = 250;
  getLineVerts = function(pos) {
    var n, verts;

    verts = [];
    n = 0;
    while (n < num_verts) {
      verts.push(new THREE.Vector3(pos.x, pos.y, pos.z));
      n += 1;
    }
    return verts;
  };
  getLineColors = function(pos) {
    var cols, n;

    cols = [];
    n = 0;
    while (n < num_verts) {
      cols.push(new THREE.Color(0xFFFFFF));
      n += 1;
    }
    return cols;
  };
  emitters = [];
  getEmitter = function(pos) {
    var emit, emitter, geo, goal_pos, goal_rote, im_special, is_frozen, line, line_anim, line_geo, line_mat, random_angle, rote_offset, rote_speed, speed, update;

    geo = new THREE.Line(head_geo, getLineMat(), THREE.LineLoop);
    geo.position = {
      x: pos.x,
      y: pos.y,
      z: 0
    };
    geo.init_pos = geo.position;
    geo.scale = {
      x: 0.0001,
      y: 0.0001,
      z: 0.0001
    };
    is_frozen = false;
    im_special = Math.random() < 0.2 ? true : false;
    speed = 1.2;
    random_angle = 0;
    goal_pos = {
      x: 150,
      y: geo.position.y
    };
    goal_rote = 0;
    rote_speed = Math.random() * 0.4 + 0.01;
    rote_offset = 0;
    update = function(pos) {
      var dist, dx, dy;

      if (this.is_frozen) {
        return;
      }
      this.goal_pos = pos;
      dx = this.geo.position.x - this.goal_pos.x;
      dy = this.geo.position.y - this.goal_pos.y;
      dist = Math.sqrt(Math.abs(dx * dx - dy * dy));
      goal_rote = Math.atan2(dy, dx) + HALF_PI + this.random_angle;
      this.goal_rote = Math.round(goal_rote * 2) * 0.5;
      this.geo.position.x -= Math.sin(this.goal_rote) * this.speed;
      this.geo.position.y += Math.cos(this.goal_rote) * this.speed;
      if (Math.abs(this.geo.position.x - this.goal_pos.x) < 1.0 && Math.abs(this.geo.position.y - this.goal_pos.y) < 1.0) {
        this.random_angle = Math.random() * 2 * Math.PI;
      }
      if (geo.init_pos.x > 0 && this.geo.position.x > geo.init_pos.x) {
        this.geo.position.x = geo.init_pos.x;
      }
      if (geo.init_pos.x < 0 && this.geo.position.x < geo.init_pos.x) {
        this.geo.position.x = geo.init_pos.x;
      }
      if (geo.init_pos.y > 0 && this.geo.position.y > geo.init_pos.y) {
        this.geo.position.y = geo.init_pos.y;
      }
      if (geo.init_pos.y < 0 && this.geo.position.y < geo.init_pos.y) {
        this.geo.position.y = geo.init_pos.y;
      }
      this.line_anim();
    };
    emit = function() {
      this.particles.geo.vertices[this.particles.index].init();
      this.particles.index += 1;
    };
    line_geo = new THREE.Geometry();
    line_geo.vertices = getLineVerts(geo.position);
    line_geo.colors = getLineColors();
    line_mat = new THREE.LineBasicMaterial({
      linewidth: Math.random() * 2 + 0.2,
      vertexColors: THREE.VertexColors
    });
    line = new THREE.Line(line_geo, line_mat);
    scene.add(line);
    line_anim = function() {
      var cur_vert, hue, i, n, next_vert, sat;

      this.line_geo.vertices[0].set(this.geo.position.x, this.geo.position.y, this.geo.position.z);
      i = this.line_geo.vertices.length - 1;
      while (i > 0) {
        n = i - 1;
        cur_vert = this.line_geo.vertices[i];
        next_vert = this.line_geo.vertices[n];
        hue = im_special ? 0.6 : 0.0;
        sat = im_special ? i / num_verts : 1 - i / num_verts;
        if (next_vert != null) {
          cur_vert.set(next_vert.x, next_vert.y, next_vert.z);
        }
        this.line_geo.colors[i].setHSL(hue, sat, (1.0 - i / num_verts) * 0.25 + 0.15);
        i -= 1;
      }
      this.line_geo.verticesNeedUpdate = true;
      this.line_geo.colorsNeedUpdate = true;
    };
    scene.add(geo);
    return emitter = {
      geo: geo,
      update: update,
      emit: emit,
      line_anim: line_anim,
      speed: speed,
      random_angle: random_angle,
      goal_rote: goal_rote,
      rote_offset: rote_offset,
      is_frozen: is_frozen,
      goal_pos: goal_pos,
      line_geo: line_geo
    };
  };
  e = 0;
  num_emitters = 100;
  while (e < num_emitters) {
    rand_angle = Math.random() * Math.PI * 2;
    radius = 150;
    emitter = getEmitter({
      x: Math.sin(rand_angle) * radius,
      y: Math.cos(rand_angle) * radius
    });
    emitters.push(emitter);
    e += 1;
  }
  toggleFollow = function() {
    var emtr, _i, _len;

    for (_i = 0, _len = emitters.length; _i < _len; _i++) {
      emtr = emitters[_i];
      emtr.random_angle = 0;
    }
  };
  toggleFreeze = function() {
    var emtr, _i, _len;

    for (_i = 0, _len = emitters.length; _i < _len; _i++) {
      emtr = emitters[_i];
      emtr.is_frozen = !emtr.is_frozen;
    }
  };
  onMouseMove = function(evt) {
    var normalized_mouseX, normalized_mouseY;

    normalized_mouseX = (evt.clientX / w.innerWidth) * 2 - 1;
    normalized_mouseY = -(evt.clientY / w.innerHeight) * 2 + 1;
    mouse = {
      x: normalized_mouseX * windowHalf.x * 0.23,
      y: normalized_mouseY * windowHalf.y * 0.23
    };
  };
  onKeyUp = function(evt) {
    log(evt.keyCode);
    if (evt.keyCode === 32) {
      toggleFollow();
    }
    if (evt.keyCode === 27) {
      toggleFreeze();
    }
  };
  renderFrame = function() {
    var emtr, _i, _len;

    requestAnimationFrame(renderFrame);
    mouse_mesh.position.x = mouse.x;
    mouse_mesh.position.y = mouse.y;
    for (_i = 0, _len = emitters.length; _i < _len; _i++) {
      emtr = emitters[_i];
      emtr.update(mouse_mesh.position);
    }
    renderer.autoClear = ctrls.auto_clear;
    return renderer.render(scene, camera);
  };
  renderFrame();
  d.addEventListener('mousemove', onMouseMove, false);
  return d.addEventListener('keyup', onKeyUp, false);
})();

/*
//@ sourceMappingURL=main.map
*/
