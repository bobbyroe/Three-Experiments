// Generated by CoffeeScript 1.7.1

/*
    A THREE.js experiment 2014 by http://bobbyroe.com
 */
(function() {
  var HALF_PI, camera, clicked, colors, controls, counter, d, distance, drawWorld, getLineMat, getWireMat, hideInfoPanel, info_panel, log, max_pos, min_pos, mouse, onKeyUp, panel, radius, renderFrame, renderer, reverse_direction, scene, showInfoPanel, sphere, sphere_geo, sphere_mat, sphere_mats_array, toggleInfoPanel, windowHalf;
  d = document;
  windowHalf = {
    x: window.innerWidth * 0.5,
    y: window.innerHeight * 0.5
  };
  mouse = {
    x: 0,
    y: 0
  };
  HALF_PI = Math.PI * 0.5;
  counter = 0;
  reverse_direction = 0;
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
  distance = 250;
  camera.position.z = distance;
  renderer = new THREE.WebGLRenderer();
  controls = new THREE.TrackballControls(camera);
  log = console.log.bind(console);
  controls.rotateSpeed = 1.0;
  controls.zoomSpeed = 1.2;
  controls.panSpeed = 0.8;
  controls.noZoom = false;
  controls.noPan = false;
  controls.staticMoving = true;
  controls.dynamicDampingFactor = 0.3;
  controls.keys = [65, 83, 68];
  renderer.setSize(window.innerWidth, window.innerHeight);
  info_panel = document.querySelector('#info');
  panel = renderer.domElement;
  panel.classList.add('panel');
  document.body.insertBefore(panel, info_panel);
  getWireMat = function(col) {
    if (col == null) {
      col = 0x660000;
    }
    return new THREE.MeshBasicMaterial({
      color: col,
      opacity: 1,
      wireframe: true,
      wireframeLinewidth: 2
    });
  };
  getLineMat = function(col) {
    return new THREE.LineBasicMaterial({
      color: col,
      linewidth: 1
    });
  };
  max_pos = {
    x: 0,
    y: 0
  };
  min_pos = {
    x: 1000,
    y: 1000
  };
  world.forEach(function(land_mass) {
    return land_mass.forEach(function(vertex) {
      min_pos = {
        x: Math.min(min_pos.x, vertex.x),
        y: Math.min(min_pos.y, vertex.y)
      };
      return max_pos = {
        x: Math.max(max_pos.x, vertex.x),
        y: Math.max(max_pos.y, vertex.y)
      };
    });
  });
  world.forEach(function(land_mass) {
    return land_mass.forEach(function(vertex) {
      var temp_y;
      temp_y = vertex.y;
      vertex.x = -1 * (vertex.x / max_pos.x) + 1;
      return vertex.y = -0.92 * (vertex.y / max_pos.y) + 0.98;
    });
  });
  radius = 100;
  world.forEach(function(land_mass) {
    return land_mass.forEach(function(vertex) {
      var phi, theta, u, v, x0, y0, z0;
      x0 = 0;
      y0 = 0;
      z0 = 0;
      u = vertex.x;
      v = vertex.y;
      theta = 2 * Math.PI * u;
      phi = Math.acos(2 * v - 1);
      vertex.x = x0 + (radius * Math.sin(phi) * Math.cos(theta));
      vertex.y = y0 + (radius * Math.cos(phi));
      return vertex.z = z0 + (radius * Math.sin(phi) * Math.sin(theta));
    });
  });
  sphere_geo = new THREE.IcosahedronGeometry(99, 3);
  sphere_mat = new THREE.MeshBasicMaterial({
    color: 0x101010,
    wireframe: false,
    transparent: true,
    opacity: 0.8
  });
  sphere_mats_array = [sphere_mat, getWireMat()];
  sphere = new THREE.SceneUtils.createMultiMaterialObject(sphere_geo, sphere_mats_array);
  scene.add(sphere);
  colors = [0xFF4400, 0x44FF00, 0x22FF00];
  drawWorld = function() {
    return world.forEach(function(land_mass, i) {
      var line, line_geo, random_color;
      random_color = i < 3 ? colors[i] : Math.random() * 0xFFFFFF;
      line_geo = new THREE.Geometry();
      line_geo.vertices = land_mass;
      line = new THREE.Line(line_geo, getLineMat(random_color));
      return sphere.add(line);
    });
  };
  drawWorld();
  onKeyUp = function(evt) {
    evt.preventDefault();
    if (evt.keyCode === 32) {
      log(min_pos, max_pos);
    }
  };
  renderFrame = function() {
    requestAnimationFrame(renderFrame);
    controls.update();
    counter += 0.01;
    sphere.rotation.y = counter;
    return renderer.render(scene, camera);
  };
  renderFrame();
  showInfoPanel = function() {
    var is_highlighing_points;
    panel.classList.add('scooched_right');
    info_panel.classList.add('open');
    return is_highlighing_points = false;
  };
  hideInfoPanel = function() {
    var is_highlighing_points;
    panel.classList.remove('scooched_right');
    info_panel.classList.remove('open');
    return is_highlighing_points = true;
  };
  toggleInfoPanel = function() {
    if (info_panel.classList.contains('open')) {
      return hideInfoPanel();
    } else {
      return showInfoPanel();
    }
  };
  clicked = function(evt) {
    if (evt.target.id === 'nub') {
      toggleInfoPanel();
    }
    if (evt.target.id === '') {
      return hideInfoPanel();
    }
  };
  d.addEventListener('click', clicked);
  return d.addEventListener('keyup', onKeyUp, false);
})();

/*
//@ sourceMappingURL=main.map
*/
