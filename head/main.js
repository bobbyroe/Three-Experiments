// Generated by CoffeeScript 1.6.2
/*
    A THREE.js experiment 2014 by http://bobbyroe.com
*/
(function() {
  var ball_geo, bouncelight, box_mat, box_mesh, camera, color_mat, controls, counter, ctrls, cube_geo, geos, getGreyMat, getMesh, getPhongMat, getRefractoBlurredMat, getRefractoMat, getWireMat, gold, gold_mat, gui, head_geo, i, init, loader, log, max_dist, mesh_scale, objects, onKeyUp, parent, postprocessing, preloadAssets, refracto_mat, renderFrame, renderer, rimlight, scene, shader, sunlight, tetra_geo, texture_blurred_cube, texture_cube, w;

  w = window;
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(60, w.innerWidth / w.innerHeight, 0.1, 20000);
  renderer = new THREE.WebGLRenderer();
  controls = new THREE.TrackballControls(camera);
  postprocessing = {
    enabled: false
  };
  texture_cube = null;
  texture_blurred_cube = null;
  log = console.log.bind(console);
  counter = 0;
  ctrls = {
    use_turntable: true,
    glass_material: false
  };
  w.ctrls = ctrls;
  gui = new dat.GUI();
  gui.add(ctrls, 'use_turntable');
  gold = gui.add(ctrls, 'glass_material');
  controls.rotateSpeed = 1.0;
  controls.zoomSpeed = 1.2;
  controls.panSpeed = 0.8;
  controls.noZoom = false;
  controls.noPan = false;
  controls.staticMoving = true;
  controls.dynamicDampingFactor = 0.3;
  controls.keys = [65, 83, 68];
  scene.fog = new THREE.FogExp2(0x00ccFF, 0.0001);
  renderer.setSize(w.innerWidth, w.innerHeight);
  document.body.appendChild(renderer.domElement);
  document.addEventListener('keyup', onKeyUp, false);
  ball_geo = new THREE.IcosahedronGeometry(0.6, 1);
  cube_geo = new THREE.CubeGeometry(1, 1, 1);
  tetra_geo = new THREE.SphereGeometry(1, 3, 2);
  loader = new THREE.OBJLoader();
  head_geo = null;
  getWireMat = function(col) {
    return new THREE.MeshBasicMaterial({
      color: col,
      opacity: 0.5,
      wireframe: true,
      wireframeLinewidth: 1
    });
  };
  getGreyMat = function() {
    return new THREE.MeshBasicMaterial({
      color: 0xFF0000,
      opacity: 1.0,
      wireframe: false
    });
  };
  getRefractoMat = function() {
    var format, img, path, urls;

    img = path = "../z_images/";
    format = '.png';
    urls = [path + 'checkers' + format, path + 'checkers' + format, path + 'checkers' + format, path + 'checkers' + format, path + 'checkers' + format, path + 'checkers' + format];
    texture_cube = THREE.ImageUtils.loadTextureCube(urls, new THREE.CubeRefractionMapping());
    return new THREE.MeshBasicMaterial({
      color: 0xFFFFFF,
      envMap: texture_cube,
      refractionRatio: 0.95
    });
  };
  getRefractoBlurredMat = function() {
    var burls, format, path;

    path = "../z_images/";
    format = '.png';
    burls = [path + 'checkers_blurred' + format, path + 'checkers_blurred' + format, path + 'checkers_blurred' + format, path + 'checkers_blurred' + format, path + 'checkers_blurred' + format, path + 'checkers_blurred' + format];
    texture_blurred_cube = THREE.ImageUtils.loadTextureCube(burls, new THREE.CubeRefractionMapping());
    return new THREE.MeshBasicMaterial({
      color: 0xFFFFFF,
      envMap: texture_blurred_cube,
      refractionRatio: 0.95
    });
  };
  getPhongMat = function() {
    var format, map_height, options, path, phong_texture_cube, urls;

    path = "images/";
    format = '.jpg';
    urls = [path + 'disturb3a' + format, path + 'disturb3a' + format, path + 'disturb3a' + format, path + 'disturb3a' + format, path + 'disturb3a' + format, path + 'disturb3a' + format];
    phong_texture_cube = THREE.ImageUtils.loadTextureCube(urls);
    map_height = THREE.ImageUtils.loadTexture("images/bump.jpg");
    map_height.anisotropy = 4;
    map_height.repeat.set(0.998, 0.998);
    map_height.offset.set(0.001, 0.001);
    map_height.wrapS = map_height.wrapT = THREE.RepeatWrapping;
    map_height.format = THREE.RGBFormat;
    options = {
      envMap: phong_texture_cube,
      bumpMap: map_height,
      color: 0xFFFFFF,
      specular: 0xFFFFFF,
      shininess: 30,
      bumpScale: 1.5,
      emissive: 0x552200,
      shading: THREE.SmoothShading
    };
    return new THREE.MeshPhongMaterial(options);
  };
  refracto_mat = getRefractoBlurredMat();
  color_mat = getRefractoMat();
  gold_mat = getPhongMat();
  geos = [cube_geo, tetra_geo];
  objects = [];
  parent = new THREE.Object3D();
  scene.add(parent);
  sunlight = new THREE.DirectionalLight(0xffffdd, 1.0);
  bouncelight = new THREE.DirectionalLight(0xddffff, 0.6);
  rimlight = new THREE.DirectionalLight(0xddffff, 1.2);
  sunlight.position.set(1, 1, 1);
  bouncelight.position.set(-1, -1, -1);
  rimlight.position.set(0, 0.5, -1);
  scene.add(rimlight);
  scene.add(sunlight);
  scene.add(bouncelight);
  max_dist = 6000;
  mesh_scale = 400;
  i = 0;
  getMesh = function(n) {
    var geometry, getGridPosition, getPosition, goal_pos, inc, material, mesh, move_rate, obj, rand, rate;

    rand = Math.random() * 100;
    inc = Math.floor(Math.random() * geos.length);
    geometry = head_geo;
    material = gold_mat;
    mesh = new THREE.Mesh(geometry, material);
    getPosition = function() {
      return {
        x: Math.random() * max_dist - max_dist * 0.5,
        y: Math.random() * max_dist - max_dist * 0.5,
        z: Math.random() * max_dist - max_dist * 0.5
      };
    };
    getGridPosition = function() {
      return {
        x: (n % 5 * mesh_scale) - 800,
        y: (Math.floor(n * 0.2) % 5 * mesh_scale) - 800,
        z: (Math.floor(n * 0.04) * -mesh_scale) + 800
      };
    };
    mesh.position = {
      x: 0,
      y: -1000,
      z: 0
    };
    mesh.scale.x = mesh.scale.y = mesh.scale.z = 1000;
    rate = Math.random() * 0.03 + 0.0;
    move_rate = Math.random() * 0.03 + 0.005;
    goal_pos = mesh.position;
    parent.add(mesh);
    return obj = {
      mesh: mesh
    };
  };
  init = function() {
    var obj;

    while (i < 1) {
      obj = getMesh(i);
      objects.push(obj);
      i += 1;
    }
    renderFrame();
  };
  shader = THREE.ShaderLib["cube"];
  shader.uniforms["tCube"].value = texture_cube;
  box_mat = new THREE.ShaderMaterial({
    fragmentShader: shader.fragmentShader,
    vertexShader: shader.vertexShader,
    uniforms: shader.uniforms,
    depthWrite: false,
    side: THREE.BackSide
  });
  box_mesh = new THREE.Mesh(new THREE.CubeGeometry(10000, 10000, 10000), box_mat);
  scene.add(box_mesh);
  camera.position.z = 2000;
  camera.position.y = 800;
  camera.position.x = -1200;
  onKeyUp = function(evnt) {
    console.log(evt.keyCode);
  };
  gold.onChange(function(use_glass_shader) {
    var obj;

    obj = objects[0];
    log(obj);
    if (use_glass_shader === false) {
      return obj.mesh.material = gold_mat;
    } else {
      return obj.mesh.material = refracto_mat;
    }
  });
  renderFrame = function() {
    requestAnimationFrame(renderFrame);
    if (ctrls.use_turntable === true) {
      counter += 0.004;
      parent.rotation.y = counter * -1;
    }
    controls.update();
    renderer.clear();
    return renderer.render(scene, camera);
  };
  preloadAssets = function() {
    loader.load('../z_objs/asaro_04a.obj', function(obj) {
      head_geo = obj.children[0].geometry;
      init();
    });
  };
  return preloadAssets();
})();

/*
//@ sourceMappingURL=main.map
*/
