// Generated by CoffeeScript 1.6.2
(function() {
  var bouncelight, box_mesh, camera, controls, counter, getBoxMat, getMesh, getPhongMat, head_geo, i, init, loader, log, max_dist, mesh_scale, model_string, objects, onKeyUp, parseQueryString, postprocessing, preloadAssets, renderFrame, renderer, rimlight, scene, sunlight, url_string;

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 20000);
  renderer = new THREE.WebGLRenderer();
  controls = new THREE.TrackballControls(camera);
  postprocessing = {
    enabled: false
  };
  log = console.log.bind(console);
  counter = 0;
  controls.rotateSpeed = 1.0;
  controls.zoomSpeed = 1.2;
  controls.panSpeed = 0.8;
  controls.noZoom = false;
  controls.noPan = false;
  controls.staticMoving = true;
  controls.dynamicDampingFactor = 0.3;
  controls.keys = [65, 83, 68];
  scene.fog = new THREE.FogExp2(0x552200, 0.0001);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  document.addEventListener('keyup', onKeyUp, false);
  loader = new THREE.OBJLoader();
  head_geo = null;
  getPhongMat = function() {
    var format, map_height, options, path, texture_cube, urls;

    path = "images/";
    format = '.jpg';
    urls = [path + 'disturb3a' + format, path + 'disturb3a' + format, path + 'disturb3a' + format, path + 'disturb3a' + format, path + 'disturb3a' + format, path + 'disturb3a' + format];
    texture_cube = THREE.ImageUtils.loadTextureCube(urls);
    map_height = THREE.ImageUtils.loadTexture("images/bump.jpg");
    map_height.anisotropy = 4;
    map_height.repeat.set(0.998, 0.998);
    map_height.offset.set(0.001, 0.001);
    map_height.wrapS = map_height.wrapT = THREE.RepeatWrapping;
    map_height.format = THREE.RGBFormat;
    options = {
      envMap: texture_cube,
      bumpMap: map_height,
      color: 0xFFFFFF,
      specular: 0xFFFFFF,
      shininess: 30,
      bumpScale: 1.5,
      emissive: 0x552200,
      shading: THREE.SmoothShading
    };
    return new THREE.MeshPhongMaterial(options);
  };
  objects = [];
  max_dist = 6000;
  mesh_scale = 400;
  i = 0;
  getMesh = function(n) {
    var anim, geometry, getGridPosition, getPosition, goal_pos, material, mesh, move_rate, obj, rate;

    geometry = head_geo;
    material = getPhongMat();
    mesh = new THREE.Mesh(geometry, material);
    getPosition = function() {
      return {
        x: Math.random() * max_dist - max_dist * 0.5,
        y: Math.random() * max_dist - max_dist * 0.5,
        z: Math.random() * max_dist - max_dist * 0.5
      };
    };
    getGridPosition = function() {
      return {
        x: (n % 5 * mesh_scale) - 800,
        y: (Math.floor(n * 0.2) % 5 * mesh_scale) - 800,
        z: (Math.floor(n * 0.04) * -mesh_scale) + 800
      };
    };
    mesh.position = {
      x: 0,
      y: -1000,
      z: 0
    };
    mesh.scale.x = mesh.scale.y = mesh.scale.z = 1000;
    rate = Math.random() * 0.03 + 0.0;
    move_rate = Math.random() * 0.03 + 0.005;
    goal_pos = mesh.position;
    anim = function() {
      var randa;

      randa = Math.random() * 1000;
      if (randa < 1) {
        goal_pos = getPosition();
      }
      this.mesh.rotation.y += rate;
      this.mesh.position.x -= (this.mesh.position.x - goal_pos.x) * move_rate;
      this.mesh.position.y -= (this.mesh.position.y - goal_pos.y) * move_rate;
      return this.mesh.position.z -= (this.mesh.position.z - goal_pos.z) * move_rate;
    };
    return obj = {
      mesh: mesh,
      anim: anim
    };
  };
  init = function() {
    var obj;

    obj = getMesh(i);
    objects.push(obj);
    scene.add(obj.mesh);
    renderFrame();
  };
  getBoxMat = function() {
    var format, path, shader, texture_cube, urls;

    path = "../../z_images/";
    format = '.png';
    urls = [path + 'checkers' + format, path + 'checkers' + format, path + 'checkers' + format, path + 'checkers' + format, path + 'checkers' + format, path + 'checkers' + format];
    texture_cube = THREE.ImageUtils.loadTextureCube(urls, new THREE.CubeRefractionMapping());
    shader = THREE.ShaderLib["cube"];
    shader.uniforms["tCube"].value = texture_cube;
    return new THREE.ShaderMaterial({
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader,
      uniforms: shader.uniforms,
      depthWrite: false,
      side: THREE.BackSide
    });
  };
  box_mesh = new THREE.Mesh(new THREE.CubeGeometry(10000, 10000, 10000), getBoxMat());
  scene.add(box_mesh);
  sunlight = new THREE.DirectionalLight(0xffffdd, 1.0);
  bouncelight = new THREE.DirectionalLight(0xddffff, 0.6);
  rimlight = new THREE.DirectionalLight(0xddffff, 1.2);
  sunlight.position.set(1, 1, 1);
  bouncelight.position.set(-1, -1, -1);
  rimlight.position.set(0, 0.5, -1);
  scene.add(rimlight);
  scene.add(sunlight);
  scene.add(bouncelight);
  camera.position.z = 2000;
  camera.position.y = 800;
  camera.position.x = -1200;
  onKeyUp = function(evnt) {
    console.log(evt.keyCode);
  };
  renderFrame = function() {
    requestAnimationFrame(renderFrame);
    controls.update();
    renderer.clear();
    counter += 0.002;
    camera.position.z = 2000 * Math.sin(counter);
    camera.position.x = -2000 * Math.cos(counter);
    camera.lookAt(scene.position);
    return renderer.render(scene, camera);
  };
  parseQueryString = function(url_frag) {
    var q_string, url_bits;

    url_bits = url_frag.split('?');
    q_string = url_bits[1] || 'obj=asaro_04a';
    return q_string.split('=')[1] + '.obj';
  };
  url_string = '' + window.location;
  model_string = parseQueryString(url_string);
  preloadAssets = function() {
    loader.load("../../z_objs/" + model_string, function(obj) {
      log(obj);
      head_geo = obj.children[0].geometry;
      init();
    });
  };
  return preloadAssets();
})();

/*
//@ sourceMappingURL=main.map
*/
