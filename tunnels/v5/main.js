// Generated by CoffeeScript 1.6.2
(function() {
  var b, box, box_geo, box_mats_array, camera, camera_uses_path, controls, counter, extrudeSettings, eye_point, eye_pos, eye_target, eye_val, getBoxWireMat, getPhongMat, getPointLight, lambert_mat, log, num_boxes, num_points, onKeyUp, p, point, point_light, points, pos, prob, renderFrame, renderer, scene, solid_mat, spline, spline_length, target, toggleFollow, tube, tube_geo, tube_mats_array, val, wire_mat;

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 40;
  controls = new THREE.TrackballControls(camera);
  controls.rotateSpeed = 1.0;
  controls.zoomSpeed = 1.2;
  controls.panSpeed = 0.8;
  controls.noZoom = false;
  controls.noPan = false;
  controls.staticMoving = true;
  controls.dynamicDampingFactor = 0.3;
  controls.keys = [65, 83, 68];
  camera_uses_path = true;
  renderer = new THREE.WebGLRenderer();
  log = console.log.bind(console);
  counter = 0;
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  points = [];
  p = 0;
  num_points = path_points.length;
  while (p < num_points) {
    points.push(new THREE.Vector3(path_points[p], path_points[p + 1], path_points[p + 2]));
    p += 3;
  }
  spline = new THREE.SplineCurve3(points);
  spline_length = spline.getLength();
  extrudeSettings = {
    amount: 20,
    bevelEnabled: false,
    bevelSegments: 2,
    steps: 15,
    extrudePath: spline
  };
  tube_geo = new THREE.TubeGeometry(extrudeSettings.extrudePath, 222, 0.65, 8, false, true);
  tube_geo.vertices.forEach(function(vert) {
    vert.x += Math.random() * 0.3 - 0.15;
    vert.y += Math.random() * 0.3 - 0.15;
    vert.z += Math.random() * 0.3 - 0.15;
  });
  tube_geo.computeFaceNormals();
  getPhongMat = function(col) {
    if (col == null) {
      col = 0x0099FF;
    }
    return new THREE.MeshPhongMaterial({
      color: col,
      specular: 0x606060,
      emissive: 0x001122,
      side: THREE.BackSide,
      shading: THREE.FlatShading
    });
  };
  lambert_mat = new THREE.MeshLambertMaterial({
    color: 0x0099FF,
    emissive: 0x001122,
    side: THREE.BackSide,
    shading: THREE.FlatShading
  });
  wire_mat = new THREE.MeshBasicMaterial({
    color: 0x002244,
    wireframe: true,
    opacity: 1.0,
    transparent: true,
    wireframeLinewidth: 2
  });
  tube_mats_array = [getPhongMat(), wire_mat];
  tube = new THREE.Mesh(tube_geo, lambert_mat);
  scene.add(tube);
  box_geo = new THREE.CubeGeometry(0.075, 0.075, 0.075);
  solid_mat = new THREE.MeshBasicMaterial({
    color: 0x440088
  });
  getBoxWireMat = function(col) {
    col || (col = 0xCC00FF);
    return new THREE.MeshBasicMaterial({
      color: col,
      wireframe: true,
      opacity: 1.0,
      transparent: true,
      wireframeLinewidth: 2
    });
  };
  box_mats_array = [solid_mat, getBoxWireMat()];
  b = 0;
  num_boxes = 30;
  while (b < num_boxes) {
    box = new THREE.BoxHelper();
    box.scale.set(0.05, 0.05, 0.05);
    box.material.color.setRGB(0.75, 0, 1.0);
    box.material.linewidth = 2;
    p = Math.max(Math.min(b / num_boxes + Math.random() * 0.05, 1), 0);
    pos = spline.getPointAt(p);
    box.position = pos;
    box.position.x += Math.random() - 0.4;
    box.position.z += Math.random() - 0.4;
    box.rotation.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);
    scene.add(box);
    getPointLight = function() {
      return new THREE.PointLight(0xFFFFFF, 0.65, 3.0);
    };
    prob = Math.random() * 1.0;
    if (prob < 0.6) {
      point_light = getPointLight();
      point_light.position = box.position;
    } else if (prob < 0.8) {
      if (point_light == null) {
        point_light = getPointLight();
      }
      point_light.color.b = 1.0;
      point_light.color.g = 1.0;
      point_light.color.r = 0.0;
    }
    if (point_light != null) {
      scene.add(point_light);
    }
    b += 1;
  }
  onKeyUp = function(evt) {
    var ESC, SPACE, z;

    SPACE = 32;
    ESC = 27;
    z = 90;
    if (evt.keyCode === 27) {
      toggleFollow();
    }
    if (evt.keyCode === z) {
      log('zap!');
    }
  };
  toggleFollow = function() {
    camera_uses_path = !camera_uses_path;
  };
  pos = new THREE.Vector3();
  point = new THREE.Vector3();
  target = new THREE.Vector3();
  eye_pos = new THREE.Vector3();
  eye_point = new THREE.Vector3();
  eye_target = new THREE.Vector3();
  val = 0.0005;
  eye_val = 0.05;
  renderFrame = function() {
    requestAnimationFrame(renderFrame);
    counter += val;
    if (counter > 0.94) {
      val = -0.0005;
      eye_val = -0.05;
    }
    if (counter < 0.06) {
      val = 0.0005;
      eye_val = 0.05;
    }
    if (camera_uses_path === true) {
      point = tube_geo.path.getPointAt(counter);
      target.subVectors(pos, point);
      target.multiplyScalar(0.1);
      pos.subVectors(pos, target);
      eye_point = tube_geo.path.getPointAt(counter + eye_val);
      eye_target.subVectors(eye_pos, eye_point);
      eye_target.multiplyScalar(0.1);
      eye_pos.subVectors(eye_pos, eye_target);
      camera.position = pos;
      camera.lookAt(eye_pos);
      camera.up.set(1, 0, 0);
    } else {
      controls.update();
    }
    return renderer.render(scene, camera);
  };
  renderFrame();
  return document.addEventListener('keyup', onKeyUp, false);
})();

/*
//@ sourceMappingURL=main.map
*/
