// Generated by CoffeeScript 1.6.2
/*
    A THREE.js experiment 2014 by http://bobbyroe.com
*/
(function() {

  const w = window;
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000000, 0.0025);
  const camera = new THREE.PerspectiveCamera(60, w.innerWidth / w.innerHeight, 0.1, 10000);
  camera.position.y = -200;
  camera.position.z = 100;
  
  const controls = new THREE.TrackballControls(camera);
  const ctrls = {
    use_turntable: false
  };
  // w.ctrls = ctrls;
  const gui = new dat.GUI();
  gui.add(ctrls, 'use_turntable');
  
  controls.rotateSpeed = 1.0;
  controls.zoomSpeed = 1.2;
  controls.panSpeed = 0.8;
  controls.noZoom = false;
  controls.noPan = false;
  controls.staticMoving = true;
  controls.dynamicDampingFactor = 0.3;
  controls.keys = [65, 83, 68];
  
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(w.innerWidth, w.innerHeight);
  document.body.appendChild(renderer.domElement);
  const log = console.log.bind(console);
  let counter = 0;
  let stop_anim = false;

  // PARTICLES
  let p_geo = new THREE.Geometry();
  let p_mat = new THREE.ParticleBasicMaterial({
    size: 0.5,
    vertexColors: true
  });
  let materials = [];
  let particles = [];
  let mesh = {};
  let stems = [];
  let num_cubes = 5;

  /*
  Returns a random point of a sphere, evenly distributed over the sphere.
  The sphere is centered at (x0,y0,z0) with the passed in radius.
  The returned point is returned as a three element array [x,y,z]. 
  
  http://stackoverflow.com/questions/5531827/random-point-on-a-given-sphere
  */

  function randomSpherePoint (opts) {

    let u = opts.u;
    let v = opts.v;
    let theta = 2 * Math.PI * u;
    let phi = Math.acos(2 * v - 1);
    return {
      u,
      v,
      x: opts.x + (opts.length * Math.sin(phi) * Math.cos(theta)),
      y: opts.y + (opts.length * Math.sin(phi) * Math.sin(theta)),
      z: opts.z + (opts.length * Math.cos(phi))
    };
  }

  let num_generations = 5;
  function getSegment (generation, verts, cols, surface_pos, parent) {

    let vertex = new THREE.Vector3();
    let prev_pos = { x: 0, y: 0, z: 0 };
    if (parent != null) {
      prev_pos = {
        x: parent.pos.x,
        y: parent.pos.y,
        z: parent.pos.z
      };
    }
    let options = {
      x: prev_pos.x,
      y: prev_pos.y,
      z: prev_pos.z,
      length: (num_generations + 10) - generation, // min length = 4
      u: surface_pos.u,
      v: surface_pos.v
    };
    let pos = randomSpherePoint(options);
    pos.magnitude = surface_pos.magnitude;
    vertex.x = pos.x;
    vertex.y = pos.y;
    vertex.z = pos.z;

    let color = new THREE.Color();
    color.setHSL((surface_pos.prob < 0.1 ? 0.33 : 0.66), 1.0, 0.5); // generation / num_generations);
    p_geo.vertices.push(vertex);
    p_geo.colors.push(color);
    verts.push(vertex);
    cols.push(color);

    function render () {

      let u = Math.max(Math.min(this.pos.u + Math.sin(counter) * this.pos.magnitude, 1), 0);
      let v = Math.max(Math.min(this.pos.v + Math.cos(counter) * this.pos.magnitude, 1), 0);
      let theta = 2 * Math.PI * u; // between 0 and 2PI
      let phi = Math.acos(2 * v - 1); // between 0 and PI
      this.vertex.x = this.pos.x + (this.length * Math.sin(phi) * Math.cos(theta));
      this.vertex.y = this.pos.y + (this.length * Math.sin(phi) * Math.sin(theta));
      this.vertex.z = this.pos.z + (this.length * Math.cos(phi));
      this.children.forEach( (child) => { child.render(); });
    }

    let segment = {
      length: options.length,
      pos,
      vertex,
      color,
      parent,
      children: [],
      render
    };

    generation += 1;
    if (generation < num_generations) {

      // 2 branches!
      let new_pos = {
        prob: surface_pos.prob,
        magnitude: surface_pos.magnitude + 0.01,
        u: surface_pos.u + 0.02,
        v: surface_pos.v
      };
      segment.children.push(getSegment(generation, verts, cols, new_pos, segment)); // recurse!

      new_pos = {
        prob: surface_pos.prob,
        magnitude: surface_pos.magnitude + 0.01,
        u: surface_pos.u - 0.02,
        v: surface_pos.v
      };
      segment.children.push(getSegment(generation, verts, cols, new_pos, segment)); // recurse!
    }
    return segment;
  }

  function getStem () {

    // line
    let line_geo = new THREE.Geometry();
    let line_mat = new THREE.LineBasicMaterial({
      vertexColors: THREE.VertexColors,
      linewidth: 1
    });
    let verts = [new THREE.Vector3(0, 0, 0)];
    let cols = [new THREE.Color(1, 0, 0)];
    let pos = {
      magnitude: 0.01,
      prob: Math.random(),
      u: Math.random(),
      v: Math.random() * 0.9 + 0.05
    };
    let stem = getSegment(0, verts, cols, pos, null);
    line_geo.vertices = verts;
    line_geo.colors = cols;

    function render () {
      if (stop_anim) {
        return;
      }
      this.line_geo.verticesNeedUpdate = true;
      return this.stem.render();
    }

    return {
      verts,
      stem,
      line_geo,
      line: new THREE.Line(line_geo, line_mat, 1), // , THREE.LineStrip),
      cols,
      render
    };
  }

  // create this thing!

  let i = 0;
  let num_stems = 30;
  let radius = 20;
  while (i < num_stems) {
    let stem = getStem();
    // scene.add(stem.line);
    stems.push(stem);
    i += 1;
  }

  particles = new THREE.ParticleSystem(p_geo, p_mat);
  scene.add(particles);

  function renderFrame () {
    requestAnimationFrame(renderFrame);
    counter += 0.1;
    stems.forEach(function(stem) {
      return stem.render();
    });
    p_geo.verticesNeedUpdate = true;
    if (ctrls.use_turntable === true) {
      camera.position.x -= (camera.position.x - 200 * Math.sin(counter * 0.02)) * 0.01;
      camera.position.y -= (camera.position.y - 200 * Math.cos(counter * 0.02)) * 0.01;
      camera.lookAt(scene.position);
    } else {
      controls.update();
    }
    return renderer.render(scene, camera);
  }

  renderFrame();

  function onKeyUp (evt) {
    evt.preventDefault();
    if (evt.keyCode === 32) {
      stop_anim = !stop_anim;
    }
  }

  document.addEventListener('keyup', onKeyUp, false);
})();
