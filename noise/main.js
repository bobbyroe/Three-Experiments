// Generated by CoffeeScript 1.6.2
var log;

log = console.log.bind(console);

(function() {
  var SCREEN_HEIGHT, SCREEN_WIDTH, animate, bloader, camera, clock, controls, directionalLight, init, mesh, meshes, mouse, noise_mat, onMouseMoved, onWindowResize, p, parent, render, renderer, scene, start;

  SCREEN_HEIGHT = window.innerHeight;
  SCREEN_WIDTH = window.innerWidth;
  camera = null;
  controls = null;
  scene = null;
  renderer = null;
  mesh = null;
  directionalLight = null;
  parent = null;
  meshes = [];
  p = null;
  bloader = null;
  clock = new THREE.Clock();
  noise_mat = null;
  start = Date.now();
  mouse = {
    x: 0,
    y: 0
  };
  init = function() {
    var ball_geo, extractNormals, getLambertMat, getWireMat, particles, shader_attrs, shader_mat, shader_uniforms;

    camera = new THREE.PerspectiveCamera(20, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 50000);
    camera.position.set(100, 100, 100);
    window.camera = camera;
    scene = new THREE.Scene();
    parent = new THREE.Object3D();
    scene.add(parent);
    camera.lookAt(scene.position);
    controls = new THREE.TrackballControls(camera);
    controls.rotateSpeed = 1.0;
    controls.zoomSpeed = 1.2;
    controls.panSpeed = 0.8;
    controls.noZoom = false;
    controls.noPan = false;
    controls.staticMoving = true;
    controls.dynamicDampingFactor = 0.3;
    controls.keys = [65, 83, 68];
    getLambertMat = function() {
      return new THREE.MeshLambertMaterial({
        color: 0xe0e0e0,
        opacity: 1.0,
        wireframe: true
      });
    };
    getWireMat = function(col) {
      if (col == null) {
        col = 0x004488;
      }
      return new THREE.MeshBasicMaterial({
        color: col,
        wireframe: true,
        wireframeLinewidth: 1
      });
    };
    ball_geo = new THREE.IcosahedronGeometry(20, 6);
    extractNormals = function(geo) {
      var face, vertex_normals, _i, _len, _ref;

      vertex_normals = [];
      _ref = geo.faces;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        face = _ref[_i];
        vertex_normals[face.a] = face.vertexNormals[0];
        vertex_normals[face.b] = face.vertexNormals[1];
        vertex_normals[face.c] = face.vertexNormals[2];
      }
      return vertex_normals;
    };
    shader_uniforms = {
      tExplosion: {
        type: "t",
        value: THREE.ImageUtils.loadTexture('explosion.png')
      },
      time: {
        type: "f",
        value: 0.0
      },
      disp: {
        type: 'f',
        value: 10.0
      }
    };
    shader_attrs = {
      vNormal: {
        type: 'v3',
        value: []
      },
      vColor: {
        type: 'f',
        value: []
      }
    };
    noise_mat = new THREE.ShaderMaterial({
      uniforms: shader_uniforms,
      attributes: shader_attrs,
      vertexShader: document.getElementById('vert').textContent,
      fragmentShader: document.getElementById('frag').textContent
    });
    shader_mat = new THREE.ShaderMaterial({
      attributes: shader_attrs,
      vertexShader: document.getElementById('vs').textContent,
      fragmentShader: document.getElementById('fs').textContent
    });
    shader_attrs.vNormal.value = extractNormals(ball_geo);
    particles = new THREE.ParticleSystem(ball_geo, noise_mat);
    parent.add(particles);
    renderer = new THREE.WebGLRenderer({
      antialias: false
    });
    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    renderer.context.getProgramInfoLog = function() {
      return '';
    };
    document.body.appendChild(renderer.domElement);
    window.addEventListener('resize', onWindowResize, false);
    return animate();
  };
  onWindowResize = function(evt) {
    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
    camera.updateProjectionMatrix();
    camera.lookAt(scene.position);
  };
  onMouseMoved = function(evt) {
    return mouse = {
      x: Math.abs(evt.clientX - SCREEN_WIDTH * 0.5) * -0.05,
      y: Math.abs(evt.clientY - SCREEN_HEIGHT * 0.5) * -0.05
    };
  };
  animate = function() {
    requestAnimationFrame(animate);
    render();
  };
  render = function() {
    var delta, _ref;

    delta = 10 * clock.getDelta();
    delta = (_ref = delta < 2) != null ? _ref : {
      delta: 2
    };
    parent.rotation.y += -0.005 * delta;
    noise_mat.uniforms['time'].value = 0.00025 * (Date.now() - start);
    noise_mat.uniforms['disp'].value = (mouse.x + mouse.y) * 0.5;
    renderer.render(scene, camera);
    controls.update();
  };
  document.addEventListener("DOMContentLoaded", init);
  document.addEventListener("mousemove", onMouseMoved);
})();

/*
//@ sourceMappingURL=main.map
*/
